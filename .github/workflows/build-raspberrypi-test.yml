name: Windows Build & Release

permissions:
  contents: write
  issues: write
  pull-requests: write

on:
  push:
    branches:
      - raspberrypi_build

jobs:
  build-and-upload-raspi:
    if: github.event.pull_request.merged == true || github.event_name == 'push'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 21
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      - name: Get Version from package.json
        id: get_version
        run: |
          VERSION=$(node -p 'require("./package.json").version')
          echo "VERSION=$VERSION" >> "$GITHUB_ENV"
          echo "Extracted version: $VERSION"

      - name: Set Build Tag
        run: |
          BUILD_TAG="-v${{ github.run_number }}"
          echo "BUILD_TAG=$BUILD_TAG" >> "$GITHUB_ENV"
          echo "Build Tag: $BUILD_TAG"

      # Build Raspberry Pi targets using electron-builder
      # Adjust targets as needed (deb, AppImage). This cross-build runs on x64 Linux.
      - name: Build Electron App (ARMv7 + ARM64)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Build ARMv7 (32-bit Raspberry Pi OS)
          npx electron-builder --linux deb,AppImage --armv7l

          # Build ARM64 (64-bit Raspberry Pi OS)
          npx electron-builder --linux deb,AppImage --arm64

      - name: List dist folder
        run: ls -R dist

      - name: Generate Release Notes
        id: generate_release_notes
        uses: release-drafter/release-drafter@v6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          version: ${{ env.VERSION }}
          name: "PulsoidApp ${{ env.VERSION }}"
          tag: ${{ env.VERSION }}
          prerelease: true
          header: "## Release Notes for PulsoidApp ${{ env.VERSION }}"

      - name: Save Release Notes
        run: |
          echo "${{ steps.generate_release_notes.outputs.body }}" > release_notes.txt

      - name: Install mc (MinIO Client) on Linux
        run: |
          curl -L "https://dl.min.io/client/mc/release/linux-amd64/mc" -o mc
          chmod +x mc
          ./mc --version

      - name: Configure mc alias
        run: |
          ./mc alias set myminio "${{ secrets.MINIO_ENDPOINT }}" "${{ secrets.AWS_ACCESS_KEY }}" "${{ secrets.AWS_SECRET_KEY }}"

      - name: Upload Raspberry Pi Artifacts to MinIO
        env:
          TARGET_PREFIX: myminio/nekosunetools/pulsoidapp/release/${{ env.VERSION }}${{ env.BUILD_TAG }}/
        run: |
          set -e

          echo "Finding ARMv7 (armv7l/armhf) artifacts..."
          APPIMG_ARMV7L=$(ls dist/*armv7l*.AppImage 2>/dev/null | head -n1 || true)
          DEB_ARMV7L=$(ls dist/*.armv7l.deb dist/*_armhf.deb 2>/dev/null | head -n1 || true)

          echo "Finding ARM64 artifacts..."
          APPIMG_ARM64=$(ls dist/*arm64*.AppImage 2>/dev/null | head -n1 || true)
          DEB_ARM64=$(ls dist/*arm64*.deb 2>/dev/null | head -n1 || true)

          echo "Uploading any found artifacts to $TARGET_PREFIX"
          for f in "$APPIMG_ARMV7L" "$DEB_ARMV7L" "$APPIMG_ARM64" "$DEB_ARM64"; do
            if [ -n "$f" ] && [ -f "$f" ]; then
              echo "Uploading $f"
              ./mc cp "$f" "$TARGET_PREFIX"
            else
              echo "No file (or not found): $f"
            fi
          done

      - name: Upload Release Notes to MinIO
        run: |
          ./mc cp release_notes.txt myminio/nekosunetools/pulsoidapp/release/${{ env.VERSION }}${{ env.BUILD_TAG }}/release_notes.txt

      - name: Compose Download Links (env)
        id: links
        run: |
          BASE_URL="https://uploadminioger1.nekosunevr.co.uk/nekosunetools/pulsoidapp/release/${{ env.VERSION }}${{ env.BUILD_TAG }}"
          # Try to detect actual filenames for nicer links (fallback to globs if missing)
          APPIMG_ARMV7L=$(ls dist/*armv7l*.AppImage 2>/dev/null | xargs -n1 -I{} basename "{}" | head -n1 || echo "")
          DEB_ARMV7L=$(ls dist/*.armv7l.deb dist/*_armhf.deb 2>/dev/null | xargs -n1 -I{} basename "{}" | head -n1 || echo "")
          APPIMG_ARM64=$(ls dist/*arm64*.AppImage 2>/dev/null | xargs -n1 -I{} basename "{}" | head -n1 || echo "")
          DEB_ARM64=$(ls dist/*arm64*.deb 2>/dev/null | xargs -n1 -I{} basename "{}" | head -n1 || echo "")

          echo "ARM7_APPIMG_URL=$([ -n "$APPIMG_ARMV7L" ] && echo "$BASE_URL/$APPIMG_ARMV7L" || echo "")" >> $GITHUB_ENV
          echo "ARM7_DEB_URL=$([ -n "$DEB_ARMV7L" ] && echo "$BASE_URL/$DEB_ARMV7L" || echo "")" >> $GITHUB_ENV
          echo "ARM64_APPIMG_URL=$([ -n "$APPIMG_ARM64" ] && echo "$BASE_URL/$APPIMG_ARM64" || echo "")" >> $GITHUB_ENV
          echo "ARM64_DEB_URL=$([ -n "$DEB_ARM64" ] && echo "$BASE_URL/$DEB_ARM64" || echo "")" >> $GITHUB_ENV

      - name: Send Release Info to Discord
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        run: |
          RELEASE_NOTES=$(cat release_notes.txt)

          # Build a human-friendly downloads section depending on what we actually built
          downloads=""
          [ -n "${ARM7_APPIMG_URL}" ] && downloads="${downloads}\n• ARMv7 AppImage: ${ARM7_APPIMG_URL}"
          [ -n "${ARM7_DEB_URL}" ] && downloads="${downloads}\n• ARMv7 .deb: ${ARM7_DEB_URL}"
          [ -n "${ARM64_APPIMG_URL}" ] && downloads="${downloads}\n• ARM64 AppImage: ${ARM64_APPIMG_URL}"
          [ -n "${ARM64_DEB_URL}" ] && downloads="${downloads}\n• ARM64 .deb: ${ARM64_DEB_URL}"
          [ -z "$downloads" ] && downloads="\n(No Raspberry Pi artifacts found to link.)"

          payload=$(jq -n \
            --arg content "<@&1384262560395559122> **UPDATE (RASPBERRY PI)**" \
            --arg title "New Release: v${{ env.VERSION }}${{ env.BUILD_TAG }}" \
            --arg desc "${RELEASE_NOTES}\n\n**Downloads**:${downloads}" \
            --arg avatar "https://cdn.discordapp.com/icons/1274732053337870417/8f0b3c1852bbd3cc11a237c2d326dcb1.webp?size=1024" \
            '{
              username: "Pulsoid APP Bot",
              avatar_url: $avatar,
              content: $content,
              embeds: [{
                title: $title,
                description: $desc,
                color: 16776960,
                footer: { text: "Released by GitHub Actions" },
                timestamp: (now | todate)
              }]
            }')

          curl -sS -X POST -H "Content-Type: application/json" -d "$payload" "$DISCORD_WEBHOOK"